<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>我的网页</title>
</head>

<body>
  <div id="app"></div>

  // proxyRef简化模版使其不用.value

  <script type="module">

    // import { reactive, toRef, proxyRefs, toRefs, effect, watch, ref, computed, watchEffect } from '../../../node_modules/@vue/runtime-dom/dist/runtime-dom.esm-browser.js'
    // import { reactive, proxyRefs, toRef, toRefs, effect, ref, computed, watch, watchEffect } from './reactivity.js'

    import { reactive, effect, ref, toRef, toRefs, computed } from "./reactivity.js"
    // vue 原来没暴露effetc api

    //用effect模拟watch
    /** 
     const runner = effect(() => {
     }, {
       scheduler() {
         runner()
       }
     })  
     */

    // watch 运行时也用到，api不在响应式模块中，但是基于响应式实现，
    const state = reactive({ name: 'cs', address: { n: { n: 'sdj' } } })
    // 分页逻辑，axios.get(/?pageSizes=${size.value} & pageNum = ${num.value})
    // 监听自己并且还是执行自己;可以用watchEffect;，很像effect。

    const unwatch = watchEffect(() => {  //effect -> reactiveEffect(getter,schedulder)
      console.log(state.name + state.age) //发现和effect很像
    }, {
      flush: "sync",// 这里是同步执行，没有实现异步，源码默认是异步处理
    })
    unwatch(); // stop watch;

    // watch(
    //   state, // 维护成取值器来监听，类似new ReactiveEffect(getter)中的getter
    //   function (oldValue, newValue, options = undefined) { //存在第三个参数没有实现
    //     console.log(oldValue, newValue)
    //   }, {
    //   deep: false,
    // }
    // )

    setTimeout(() => {
      state.name = 'abc';
      state.name = 'def'; // 实际只会执行一次，有个异步机制没实现
    }, 1000);

    // computed 和watch 是  vue3基于effect实现 ，vue2基于watcher实现
  </script>
</body>

</html>